from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
import joblib
import pandas as pd
import logging

# Set up logging
logging.basicConfig(level=logging.DEBUG)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://med-techai.vercel.app"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# Load the trained model
try:
    pipeline = joblib.load('new_diabetes_model.pkl')
    logging.info("Pipeline loaded successfully")
    
    # Extract components from the pipeline
    model = pipeline.named_steps['classifier']
    scaler = pipeline.named_steps['scaler']
    
    logging.info(f"Model is an {type(model)}")
    
    # Get feature names
    if hasattr(model, 'feature_names_in_'):
        feature_names = model.feature_names_in_
    else:
        feature_names = [
            'HighBP', 'HighChol', 'CholCheck', 'BMI', 'Smoker', 'Stroke',
            'HeartDiseaseorAttack', 'PhysActivity', 'Fruits', 'Veggies',
            'HvyAlcoholConsump', 'AnyHealthcare', 'NoDocbcCost', 'GenHlth',
            'MentHlth', 'PhysHlth', 'DiffWalk', 'Sex', 'Age', 'Education', 'Income'
        ]
    logging.info(f"Features expected: {feature_names}")

except Exception as e:
    logging.error(f"Error loading model: {e}", exc_info=True)
    raise

class UserInput(BaseModel):
    high_bp: int = Field(..., ge=0, le=1)
    high_chol: int = Field(..., ge=0, le=1)
    chol_check: int = Field(..., ge=0, le=1)
    bmi: float = Field(..., gt=0)
    smoker: int = Field(..., ge=0, le=1)
    stroke: int = Field(..., ge=0, le=1)
    heart_disease: int = Field(..., ge=0, le=1)
    phys_activity: int = Field(..., ge=0, le=1)
    fruits: int = Field(..., ge=0, le=1)
    veggies: int = Field(..., ge=0, le=1)
    alcohol: int = Field(..., ge=0, le=1)
    healthcare: int = Field(..., ge=0, le=1)
    no_doc_cost: int = Field(..., ge=0, le=1)
    gen_health: int = Field(..., ge=1, le=5)
    ment_health: int = Field(..., ge=0, le=30)
    phys_health: int = Field(..., ge=0, le=30)
    diff_walk: int = Field(..., ge=0, le=1)
    sex: int = Field(..., ge=0, le=1)
    age: int = Field(..., ge=1, le=13)
    education: int = Field(..., ge=1, le=6)
    income: int = Field(..., ge=1, le=8)

MEDICAL_DISCLAIMER = (
    "Disclaimer: This prediction is generated by an artificial intelligence model and "
    "is for informational purposes only. It does not constitute medical advice, diagnosis, "
    "or treatment. Always seek the advice of a qualified healthcare professional for "
    "any medical concerns or before making any decisions related to your health."
)

@app.get("/")
async def root():
    return {"message": "Welcome to the Diabetes Prediction API. Use POST /predict to make predictions."}

@app.post("/predict")
async def predict_diabetes(data: UserInput):
    try:
        # Input validation
        if data.gen_health <= 2 and (data.ment_health > 10 or data.phys_health > 10):
            raise ValueError(
                "Inconsistent data: General health rated as 'Excellent' or 'Very good' "
                "but mental or physical health days exceed 10."
            )

        # Prepare input data
        input_values = [
            data.high_bp, data.high_chol, data.chol_check, data.bmi,
            data.smoker, data.stroke, data.heart_disease, data.phys_activity,
            data.fruits, data.veggies, data.alcohol, data.healthcare,
            data.no_doc_cost, data.gen_health, data.ment_health, data.phys_health,
            data.diff_walk, data.sex, data.age, data.education, data.income
        ]
        
        input_df = pd.DataFrame([input_values], columns=feature_names)
        
        # Scale the input data
        scaled_input = scaler.transform(input_df)
        
        # Get probabilities first
        probabilities = model.predict_proba(scaled_input)[0]
        diabetes_prob = probabilities[1]  # Probability of diabetes/prediabetes
        
        # Make prediction based on threshold (0.5 is standard for binary classification)
        prediction = 1 if diabetes_prob >= 0.5 else 0
        
        # Result mapping
        result_map = {
            0: "No Diabetes Detected",
            1: "Potential Diabetes/Prediabetes Risk",
        }
        prediction_label = result_map.get(prediction, "Unknown Status")

        # Generate personalized AI-like advice
        if prediction == 0:
            advice = (
                "Great news! üéâ My analysis suggests you‚Äôre in the clear‚Äîno diabetes detected. To keep things that way, I‚Äôd recommend sticking to a healthy diet ü•ó, staying active üèÉ, and getting regular check-ups with your doctor. Staying proactive with screenings is a smart move for catching any changes early!"
            )
        else:
            advice = (
                "Hmm‚Ä¶ my analysis shows a potential risk for diabetes or prediabetes. üìä This could mean your blood sugar levels might be higher than usual, or you have some risk factors. I‚Äôd strongly suggest reaching out to a healthcare professional‚Äîlike a doctor, endocrinologist, or nutritionist‚Äîfor a thorough check-up and personalized guidance. Early action is key to managing this and preventing any complications down the road. You‚Äôve got this! üí™"
            )

        # Prepare probability information
        probabilities_info = {
            "No Diabetes Probability": round(probabilities[0] * 100, 2),
            "Diabetes/Prediabetes Probability": round(probabilities[1] * 100, 2)
        }

        return {
            "prediction": prediction_label,
            "advice": advice,
            "disclaimer": MEDICAL_DISCLAIMER,
            "probabilities": probabilities_info,
            "raw_prediction": float(prediction),
            "raw_probability": float(diabetes_prob)
        }

    except HTTPException as http_exc: # Catch HTTPExceptions specifically to re-raise them
        raise http_exc
    except ValueError as ve: # Changed to send a simple string in detail
        logging.error(f"Validation error: {ve}")
        raise HTTPException(
            status_code=400,
            detail=f"Input data error: {str(ve)}" # Detail is now a string
        )
    except Exception as e: # Changed to send a simple string in detail
        logging.error(f"Error during prediction: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Prediction failed due to an internal server error: {str(e)}" # Detail is now a string
        )