from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
import joblib
import pandas as pd
import logging

# Set up logging
logging.basicConfig(level=logging.DEBUG)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://med-techai.vercel.app"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# Load the trained model
try:
    pipeline = joblib.load('new_diabetes_model.pkl')
    logging.info("Pipeline loaded successfully")
    
    # Extract components from the pipeline
    model = pipeline.named_steps['classifier']
    scaler = pipeline.named_steps['scaler']
    
    logging.info(f"Model is an {type(model)}")
    
    # Get feature names
    if hasattr(model, 'feature_names_in_'):
        feature_names = model.feature_names_in_
    else:
        feature_names = [
            'HighBP', 'HighChol', 'CholCheck', 'BMI', 'Smoker', 'Stroke',
            'HeartDiseaseorAttack', 'PhysActivity', 'Fruits', 'Veggies',
            'HvyAlcoholConsump', 'AnyHealthcare', 'NoDocbcCost', 'GenHlth',
            'MentHlth', 'PhysHlth', 'DiffWalk', 'Sex', 'Age', 'Education', 'Income'
        ]
    logging.info(f"Features expected: {feature_names}")

except Exception as e:
    logging.error(f"Error loading model: {e}", exc_info=True)
    raise

class UserInput(BaseModel):
    high_bp: int = Field(..., ge=0, le=1)
    high_chol: int = Field(..., ge=0, le=1)
    chol_check: int = Field(..., ge=0, le=1)
    bmi: float = Field(..., gt=0)
    smoker: int = Field(..., ge=0, le=1)
    stroke: int = Field(..., ge=0, le=1)
    heart_disease: int = Field(..., ge=0, le=1)
    phys_activity: int = Field(..., ge=0, le=1)
    fruits: int = Field(..., ge=0, le=1)
    veggies: int = Field(..., ge=0, le=1)
    alcohol: int = Field(..., ge=0, le=1)
    healthcare: int = Field(..., ge=0, le=1)
    no_doc_cost: int = Field(..., ge=0, le=1)
    gen_health: int = Field(..., ge=1, le=5)
    ment_health: int = Field(..., ge=0, le=30)
    phys_health: int = Field(..., ge=0, le=30)
    diff_walk: int = Field(..., ge=0, le=1)
    sex: int = Field(..., ge=0, le=1)
    age: int = Field(..., ge=1, le=13)
    education: int = Field(..., ge=1, le=6)
    income: int = Field(..., ge=1, le=8)

MEDICAL_DISCLAIMER = (
    "Disclaimer: This prediction is generated by an artificial intelligence model and "
    "is for informational purposes only. It does not constitute medical advice, diagnosis, "
    "or treatment. Always seek the advice of a qualified healthcare professional for "
    "any medical concerns or before making any decisions related to your health."
)

@app.get("/")
async def root():
    return {"message": "Welcome to the Diabetes Prediction API. Use POST /predict to make predictions."}

@app.post("/predict")
async def predict_diabetes(data: UserInput):
    try:
        # Input validation
        if data.gen_health <= 2 and (data.ment_health > 10 or data.phys_health > 10):
            raise ValueError(
                "Inconsistent data: General health rated as 'Excellent' or 'Very good' "
                "but mental or physical health days exceed 10."
            )

        # Prepare input data
        input_values = [
            data.high_bp, data.high_chol, data.chol_check, data.bmi,
            data.smoker, data.stroke, data.heart_disease, data.phys_activity,
            data.fruits, data.veggies, data.alcohol, data.healthcare,
            data.no_doc_cost, data.gen_health, data.ment_health, data.phys_health,
            data.diff_walk, data.sex, data.age, data.education, data.income
        ]
        
        input_df = pd.DataFrame([input_values], columns=feature_names)
        
        # Scale the input data
        scaled_input = scaler.transform(input_df)
        
        # Get probabilities first
        probabilities = model.predict_proba(scaled_input)[0]
        diabetes_prob = probabilities[1]  # Probability of diabetes/prediabetes
        
        # Make prediction based on threshold (0.5 is standard for binary classification)
        prediction = 1 if diabetes_prob >= 0.5 else 0
        
        # Result mapping
        result_map = {
            0: "No Diabetes Detected",
            1: "Potential Diabetes/Prediabetes Risk",
        }
        prediction_label = result_map.get(prediction, "Unknown Status")

        # Generate appropriate advice
        if prediction == 0:
            advice = (
                "Based on the provided information, the model indicates 'No Diabetes Detected'. "
                "To maintain good health, continue to prioritize a balanced diet, regular physical "
                "activity, and routine medical check-ups. Regular health screenings are always "
                "recommended for early detection of any potential health changes."
            )
        else:
            advice = (
                "The model indicates a 'Potential Diabetes/Prediabetes Risk'. This suggests that your "
                "blood sugar levels may be elevated, or you have risk factors consistent with diabetes. "
                "It is **highly recommended** that you consult with a healthcare professional (doctor, "
                "endocrinologist, or nutritionist) for comprehensive medical evaluation, further testing, "
                "diagnosis, and personalized advice on treatment and lifestyle changes. Early detection, "
                "diagnosis, and management are crucial for preventing or delaying serious complications."
            )

        # Prepare probability information
        probabilities_info = {
            "No Diabetes Probability": round(probabilities[0] * 100, 2),
            "Diabetes/Prediabetes Probability": round(probabilities[1] * 100, 2)
        }

        return {
            "prediction": prediction_label,
            "advice": advice,
            "disclaimer": MEDICAL_DISCLAIMER,
            "probabilities": probabilities_info,
            "raw_prediction": float(prediction),
            "raw_probability": float(diabetes_prob)
        }

    except ValueError as ve:
        logging.error(f"Validation error: {ve}")
        raise HTTPException(
            status_code=400,
            detail=[{"loc": ["body"], "msg": str(ve)}]
        )
    except Exception as e:
        logging.error(f"Error during prediction: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=[{"loc": ["server"], "msg": f"Prediction error: {str(e)}"}]
        )