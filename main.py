from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
import joblib
import numpy as np
import pandas as pd
import logging
import xgboost as xgb

# Set up logging
logging.basicConfig(level=logging.DEBUG)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://med-techai.vercel.app"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# Log the xgboost version
logging.info(f"Using xgboost version: {xgb.__version__}")

# Load the trained model
try:
    model = joblib.load('diabetes_model.pkl')
    logging.info("Model loaded successfully")
    
    if isinstance(model, xgb.XGBClassifier):
        logging.info(f"Model is an XGBClassifier with parameters: {model.get_params()}")
    
    if hasattr(model, 'feature_names_in_'):
        feature_names = model.feature_names_in_
        logging.info(f"Model expects features: {list(feature_names)}")
    else:
        feature_names = [
            'HighBP', 'HighChol', 'CholCheck', 'BMI', 'Smoker', 'Stroke',
            'HeartDiseaseorAttack', 'PhysActivity', 'Fruits', 'Veggies',
            'HvyAlcoholConsump', 'AnyHealthcare', 'NoDocbcCost', 'GenHlth',
            'MentHlth', 'PhysHlth', 'DiffWalk', 'Sex', 'Age', 'Education', 'Income'
        ]
        logging.warning("Model does not expose feature_names_in_. Using hardcoded feature names.")
        logging.info(f"Hardcoded features: {feature_names}")

except Exception as e:
    logging.error(f"Error loading model: {e}", exc_info=True)
    raise

class UserInput(BaseModel):
    high_bp: int = Field(..., ge=0, le=1)
    high_chol: int = Field(..., ge=0, le=1)
    chol_check: int = Field(..., ge=0, le=1)
    bmi: float = Field(..., gt=0)
    smoker: int = Field(..., ge=0, le=1)
    stroke: int = Field(..., ge=0, le=1)
    heart_disease: int = Field(..., ge=0, le=1)
    phys_activity: int = Field(..., ge=0, le=1)
    fruits: int = Field(..., ge=0, le=1)
    veggies: int = Field(..., ge=0, le=1)
    alcohol: int = Field(..., ge=0, le=1)
    healthcare: int = Field(..., ge=0, le=1)
    no_doc_cost: int = Field(..., ge=0, le=1)
    gen_health: int = Field(..., ge=1, le=5)
    ment_health: int = Field(..., ge=0, le=30)
    phys_health: int = Field(..., ge=0, le=30)
    diff_walk: int = Field(..., ge=0, le=1)
    sex: int = Field(..., ge=0, le=1)
    age: int = Field(..., ge=1, le=13)
    education: int = Field(..., ge=1, le=6)
    income: int = Field(..., ge=1, le=8)

MEDICAL_DISCLAIMER = (
    "Disclaimer: This prediction is generated by an artificial intelligence model and "
    "is for informational purposes only. It does not constitute medical advice, diagnosis, "
    "or treatment. Always seek the advice of a qualified healthcare professional for "
    "any medical concerns or before making any decisions related to your health."
)

@app.get("/")
async def root():
    return {"message": "Welcome to the Diabetes Prediction API. Use POST /predict to make predictions."}

@app.post("/predict")
async def predict_diabetes(data: UserInput):
    try:
        if data.gen_health <= 2 and (data.ment_health > 10 or data.phys_health > 10):
            raise ValueError(
                "Inconsistent data: General health rated as 'Excellent' or 'Very good' "
                "but mental or physical health days exceed 10."
            )

        input_values = [
            data.high_bp, data.high_chol, data.chol_check, data.bmi,
            data.smoker, data.stroke, data.heart_disease, data.phys_activity,
            data.fruits, data.veggies, data.alcohol, data.healthcare,
            data.no_doc_cost, data.gen_health, data.ment_health, data.phys_health,
            data.diff_walk, data.sex, data.age, data.education, data.income
        ]
        logging.debug(f"Received data (dict): {data.dict()}")
        logging.debug(f"Input values list: {input_values}")

        if 'feature_names' not in globals():
            raise RuntimeError("Feature names not determined. Model loading might have failed or model type is unexpected.")

        input_df = pd.DataFrame([input_values], columns=feature_names)
        logging.debug(f"Input DataFrame for prediction:\n{input_df}")

        prediction = model.predict(input_df)[0]
        logging.debug(f"Raw prediction: {prediction}")

        result_map = {
            0: "No Diabetes Detected",
            1: "Potential Diabetes/Prediabetes Risk",
        }
        prediction_label = result_map.get(prediction, "Unknown Status")

        advice = ""
        if prediction == 0:
            advice = (
                "Based on the provided information, the model indicates 'No Diabetes Detected'. "
                "To maintain good health, continue to prioritize a balanced diet, regular physical "
                "activity, and routine medical check-ups. Regular health screenings are always "
                "recommended for early detection of any potential health changes."
            )
        elif prediction == 1:
            advice = (
                "The model indicates a 'Potential Diabetes/Prediabetes Risk'. This suggests that your "
                "blood sugar levels may be elevated, or you have risk factors consistent with diabetes. "
                "It is **highly recommended** that you consult with a healthcare professional (doctor, "
                "endocrinologist, or nutritionist) for comprehensive medical evaluation, further testing, "
                "diagnosis, and personalized advice on treatment and lifestyle changes. Early detection, "
                "diagnosis, and management are crucial for preventing or delaying serious complications."
            )
        else:
            advice = "An unexpected prediction was made. Please consult a healthcare professional for guidance regarding your health status."

        probabilities_info = {}
        if hasattr(model, 'predict_proba'):
            probabilities = model.predict_proba(input_df)[0]
            logging.debug(f"Prediction probabilities: {probabilities}")
            probabilities_info = {
                "No Diabetes Probability": round(probabilities[0] * 100, 2),
                "Diabetes/Prediabetes Probability": round(probabilities[1] * 100, 2)
            }

        return {
            "prediction": prediction_label,
            "advice": advice,
            "disclaimer": MEDICAL_DISCLAIMER,
            "probabilities": probabilities_info
        }

    except ValueError as ve:
        logging.error(f"Validation error: {ve}")
        raise HTTPException(
            status_code=400,
            detail=[{"loc": ["body"], "msg": str(ve)}]
        )
    except Exception as e:
        logging.error(f"Error during prediction: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=[{"loc": ["server"], "msg": f"Prediction error: {str(e)}"}]
        )