from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
import joblib
import numpy as np
import pandas as pd
import logging

# Set up logging
logging.basicConfig(level=logging.DEBUG)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://med-techai.vercel.app"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# Load the trained model
try:
    model = joblib.load('diabetes_model.pkl')
    print("Model loaded successfully")
    if hasattr(model, 'feature_names_in_'):
        feature_names = model.feature_names_in_
        print(f"Model expects features: {list(feature_names)}")
    else:
        # IMPORTANT: This list MUST EXACTLY match the feature names and their order
        # used when training your 'diabetes_model.pkl'.
        feature_names = [
            'HighBP', 'HighChol', 'CholCheck', 'BMI', 'Smoker', 'Stroke',
            'HeartDiseaseorAttack', 'PhysActivity', 'Fruits', 'Veggies',
            'HvyAlcoholConsump', 'AnyHealthcare', 'NoDocbcCost', 'GenHlth',
            'MentHlth', 'PhysHlth', 'DiffWalk', 'Sex', 'Age', 'Education', 'Income'
        ]
        print("Warning: Model does not expose feature_names_in_. Using hardcoded feature names.")
        print(f"Hardcoded features: {feature_names}")

except Exception as e:
    print(f"Error loading model: {e}")
    raise

class UserInput(BaseModel):
    # Field mappings to dataset columns - Ensure these match your model's expected order
    high_bp: int = Field(..., ge=0, le=1)  # HighBP
    high_chol: int = Field(..., ge=0, le=1)  # HighChol
    chol_check: int = Field(..., ge=0, le=1)  # CholCheck
    bmi: float = Field(..., gt=0)  # BMI
    smoker: int = Field(..., ge=0, le=1)  # Smoker
    stroke: int = Field(..., ge=0, le=1)  # Stroke
    heart_disease: int = Field(..., ge=0, le=1)  # HeartDiseaseorAttack
    phys_activity: int = Field(..., ge=0, le=1)  # PhysActivity
    fruits: int = Field(..., ge=0, le=1)  # Fruits
    veggies: int = Field(..., ge=0, le=1)  # Veggies
    alcohol: int = Field(..., ge=0, le=1)  # HvyAlcoholConsump
    healthcare: int = Field(..., ge=0, le=1)  # AnyHealthcare
    no_doc_cost: int = Field(..., ge=0, le=1)  # NoDocbcCost
    gen_health: int = Field(..., ge=1, le=5)  # GenHlth
    ment_health: int = Field(..., ge=0, le=30)  # MentHlth
    phys_health: int = Field(..., ge=0, le=30)  # PhysHlth
    diff_walk: int = Field(..., ge=0, le=1)  # DiffWalk
    sex: int = Field(..., ge=0, le=1)  # Sex
    age: int = Field(..., ge=1, le=13)  # Age
    education: int = Field(..., ge=1, le=6)  # Education
    income: int = Field(..., ge=1, le=8)  # Income

# Define the standard medical disclaimer
MEDICAL_DISCLAIMER = (
    "Disclaimer: This prediction is generated by an artificial intelligence model and "
    "is for informational purposes only. It does not constitute medical advice, diagnosis, "
    "or treatment. Always seek the advice of a qualified healthcare professional for "
    "any medical concerns or before making any decisions related to your health."
)

@app.get("/")
async def root():
    return {"message": "Welcome to the Diabetes Prediction API. Use POST /predict to make predictions."}

@app.post("/predict")
async def predict_diabetes(data: UserInput):
    try:
        input_values = [
            data.high_bp, data.high_chol, data.chol_check, data.bmi,
            data.smoker, data.stroke, data.heart_disease, data.phys_activity,
            data.fruits, data.veggies, data.alcohol, data.healthcare,
            data.no_doc_cost, data.gen_health, data.ment_health, data.phys_health,
            data.diff_walk, data.sex, data.age, data.education, data.income
        ]
        logging.debug(f"Received data (dict): {data.dict()}")
        logging.debug(f"Input values list: {input_values}")

        if 'feature_names' not in globals():
            raise RuntimeError("Feature names not determined. Model loading might have failed or model type is unexpected.")

        input_df = pd.DataFrame([input_values], columns=feature_names)
        logging.debug(f"Input DataFrame for prediction:\n{input_df}")

        prediction = model.predict(input_df)[0]
        logging.debug(f"Raw prediction: {prediction}")

        # Map numerical prediction to human-readable string
        result_map = {
            0: "No Diabetes Detected",
            1: "Potential Prediabetes / Prediabetes Risk",
        }
        prediction_label = result_map.get(prediction, "Unknown Status")

        # Generate tailored advice based on prediction
        advice = ""
        if prediction == 0: # No Diabetes
            advice = (
                "Based on the provided information, the model indicates 'No Diabetes Detected'. "
                "To maintain good health, continue to prioritize a balanced diet, regular physical "
                "activity, and routine medical check-ups. Regular health screenings are always "
                "recommended for early detection of any potential health changes."
            )
        elif prediction == 1: # Prediabetes
            advice = (
                "The model suggests 'Potential Prediabetes Risk'. This indicates that your blood sugar "
                "levels are higher than normal but not yet high enough to be classified as type 2 diabetes. "
                "This is a critical stage where lifestyle interventions can prevent or delay the onset of diabetes. "
                "It is **highly recommended** that you consult with a healthcare professional (doctor, endocrinologist, "
                "or nutritionist) for personalized advice, further testing, and guidance on dietary changes, "
                "exercise plans, and weight management. Early intervention is key."
            )
        else : # Diabetes
            advice = (
                "An unexpected prediction was made. Please consult a healthcare professional for guidance regarding your health status."
            )
        

        # Optional: Get prediction probabilities if your model supports it
        probabilities_info = {}
        if hasattr(model, 'predict_proba'):
            probabilities = model.predict_proba(input_df)[0]
            logging.debug(f"Prediction probabilities: {probabilities}")
            # Assuming probabilities order corresponds to result_map (0, 1, 2)
            probabilities_info = {
                "No Diabetes Probability": round(probabilities[0] * 100, 2),
                "Prediabetes Probability": round(probabilities[1] * 100, 2),
                "Diabetes Probability": round(probabilities[2] * 100, 2)
            }

        return {
            "prediction": prediction_label,
            "advice": advice,
            "disclaimer": MEDICAL_DISCLAIMER,
            "probabilities": probabilities_info # Include probabilities for more detail
        }
    except Exception as e:
        logging.error(f"Error during prediction: {e}", exc_info=True)
        raise HTTPException(status_code=400, detail=f"Prediction error: {e}")